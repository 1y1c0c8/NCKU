## 人工智慧導論 hw2
### 如何實現P1
- 先實作一個回傳城市組合的function (named perms())
- 根據需求，將由初始城市出發的組合從所有組合中篩選出來，以減少路徑加總及路徑長度比較次數
- 由 'ans_city_order' 以及 'ans_min_path' 紀錄最小路徑長度及其路徑為何

### 如何實現P2
- 產生一種路徑隨機組合(P)作為P_current，並計算其路徑長度
- 交換兩個隨機城市的順序(P')，計算路徑長度並與比較P, P'
    - P' <= P 時更新 P_current
    - P' > P 時進行退火
        - 符合條件 -> 更新P_current
        - 不符合條件 -> 不更新

### P2實作過程的觀察？改變參數會對結果造成什麼影響？（可視覺化呈現）
- 模擬退火法在本次應用中確實能找到相對短的路徑
- 沒有做完整的測試，但有以下發現
    - 在迭代次數不夠大(ex. 10次)的情況下，一個5*5的matrix就有機率得到區域最佳解而非全域最佳解
    - cooling_rate越小時，有越大的機會得出全域最佳解
    - temp以及cooling_rate對exp(delta(path_len)/temp)的影響是反比，故temp對模擬退火法效果的影響與cooling_rate相反

### 比較P1級P2的優缺點及實作心得
- 因為沒有規模較大的測資及正確解能夠測試，故僅能以推論言之
- Brute Force肯定能找出全域最佳解，但一旦規模上升，運算時間也會提升。Simulated Annealing能夠以iteration, temp, cooling_rate等參數限制運算次數，並且給出「相對」適合的答案（或者是說堪用），兩者各有優缺點，端視使用者需求選擇。
- 理解模擬退火法之後做起來不算太複雜，我覺得這個名字選的很酷XD。
- 我在BF.py以及SA.py中實作了可以給出list元素所有排列的函式，其實python在itertools有提供類似函式，想知道如果自己寫一些與實作重點不是很相關的函式在這堂課是否能夠接受。
- 希望下次會有參考測資及答案可以使用><（雖然大概可以自己弄，但我擔心自製大型測資的解答會算錯QQ）